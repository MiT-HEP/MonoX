/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

#include "Riostream.h" 

#include "KeysShape.h"

#include "RooRealVar.h"

#include "TMath.h"
#include "TSystem.h"
#include "TString.h"
#include "TThread.h"

#include <stdexcept>
#include <cstring>

ClassImp(KeysShape)
ClassImp(KeysShape::CalcData)

double const sqrt2pi(TMath::Sqrt(2. * TMath::Pi()));
double const cutoff(5.);

KeysShape::KeysShape(const char *name, const char *title, RooRealVar& _x, TTree& _ntuples, const char* _wgtVar/* = 0*/, double _rho/* = 0.5*/, unsigned _nCPU/* = 1*/, unsigned _nBins/* = 1000*/) :
  StaticShape(name, title, _x, _x.getMin(), _x.getMax(), 0, _nBins + 1)
{
  TString wgtVar(TString(_wgtVar).Strip(TString::kBoth));

  // setup input data
  if (!_ntuples.GetLeaf(_x.GetName()) || (wgtVar.Length() != 0 && !_ntuples.GetLeaf(wgtVar)))
    throw std::invalid_argument("Input tree does not have necessary variables");

  if (_ntuples.GetEstimate() <= _ntuples.GetEntries())
    throw std::runtime_error("Ntuples estimate size too small");

  TString columns(_x.GetName());
  if (wgtVar.Length() != 0) {
    columns += ":";
    columns += wgtVar;
  }

  // nData can be different from nEntries when Event/EntryList is loaded to the tree
  long nData(_ntuples.Draw(columns, "", "goff"));
  double* xdata(_ntuples.GetV1());
  double* wdata(wgtVar.Length() != 0 ? _ntuples.GetV2() : 0);

  // std::vector<double> dataval(xdata, xdata + nData);
  // std::vector<double> datawgt(wdata ? nData : 0);

  // for(long iRow(0); iRow != nData; ++iRow){
  //   dataval[iRow] = xdata[iRow];
  //   if(wdata) datawgt[iRow] = wdata[iRow];
  // }

  //  _calculate(nData, &(dataval[0]), wdata ? &(datawgt[0]) : 0, _rho, _nCPU);
  _calculate(nData, xdata, wdata, _rho, _nCPU);
}

KeysShape::KeysShape(const char *name, const char *title, RooRealVar& _x, RooDataSet& _dataset, double _rho/* = 0.5*/, unsigned _nCPU/* = 1*/, unsigned _nBins/* = 1000*/) :
  StaticShape(name, title, _x, _x.getMin(), _x.getMax(), 0, _nBins + 1)
{
  // setup input data
  RooRealVar* datax(static_cast<RooRealVar*>(_dataset.get()->find(_x.GetName())));
  if(!datax)
    throw std::invalid_argument("Input dataset not compatible");

  unsigned nData(_dataset.numEntries());

  std::vector<double> dataval(nData);
  std::vector<double> datawgt(_dataset.isWeighted() ? nData : 0);

  for(unsigned iRow(0); iRow != nData; ++iRow){
    _dataset.get(iRow);
    dataval[iRow] = datax->getVal();
    if(_dataset.isWeighted()) datawgt[iRow] = _dataset.weight();
  }

  _calculate(nData, &(dataval[0]), _dataset.isWeighted() ? &(datawgt[0]) : 0, _rho, _nCPU);
}

void
KeysShape::_calculate(unsigned _nData, double const* _dataval, double const* _datawgt, double _rho, unsigned _nCPU)
{
  CalcData cd(ny_, yvals_);

  cd.nData = _nData;
  cd.dataval = _dataval;
  cd.datawgt = _datawgt;

  double sumxw(0.);
  double sumx2w(0.);
  for(unsigned iRow(0); iRow != _nData; ++iRow){
    double xval(_dataval[iRow]);
    double weight(_datawgt ? _datawgt[iRow] : 1.);

    cd.sumw += weight;
    sumxw += xval * weight;
    sumx2w += xval * xval * weight;
  }

  if (cd.sumw < 0. || sumxw < 0. || sumx2w < 0.)
    throw std::runtime_error("Negative sumw");

  double globalMean(sumxw / cd.sumw);
  double globalSigma(TMath::Sqrt(sumx2w / cd.sumw - globalMean * globalMean));
  cd.h0 = TMath::Power(4. / 3. / cd.nData, 0.2) * globalSigma;
  cd.h1 = cd.h0 / TMath::Sqrt(globalSigma);

  cd.xmin = xvals_[0];
  cd.delta = (xvals_[1] - xvals_[0]) / (ny_ - 1);
  cd.rho = _rho;

  if(_nCPU == 1){
    cd.offset = 0;
    cd.step = 1;

    _calculateYVals(reinterpret_cast<void*>(&cd));
  }
  else{
    if(gSystem->Load("libThread.so") < 0)
      throw std::runtime_error("Multi-thread not supported");

    std::vector<TThread*> threads(_nCPU, 0);
    cd.step = _nCPU;

    cd.ownYvals = true;
    std::vector<CalcData> cdCopies(_nCPU - 1, cd);
    cd.ownYvals = false;

    for(unsigned iCPU(0); iCPU != _nCPU; ++iCPU){
      CalcData* datap(iCPU == 0 ? &cd : &(cdCopies[iCPU - 1]));
      datap->offset = iCPU;

      threads[iCPU] = new TThread(TString::Format("th%d",iCPU), TThread::VoidRtnFunc_t(&KeysShape::_calculateYVals), datap);
      threads[iCPU]->Run();
    }

    for(unsigned iCPU(0); iCPU != _nCPU; ++iCPU){
      threads[iCPU]->Join();
      TThread::Delete(threads[iCPU]);
      delete threads[iCPU];

      if(iCPU == 0) continue;

      for(unsigned iP(0); iP != ny_; ++iP)
    	yvals_[iP] += cdCopies[iCPU - 1].yvals[iP];
    }

    for (unsigned iP(0); iP != ny_; ++iP) {
      if (yvals_[iP] < 0.) {
        std::cout << "Info (KeysShape): Forcing yvalue @ (x = " << xvals_[iP] << ") to 0" << std::endl;
        yvals_[iP] = 0.;
      }
    }
  }
}

/*static*/
void*
KeysShape::_calculateYVals(void* _cd)
{
  CalcData& cd(*reinterpret_cast<CalcData*>(_cd));

  double norm0(1. / cd.sumw / cd.h0 / sqrt2pi);
  
  for(unsigned iRow(cd.offset); iRow < cd.nData; iRow += cd.step){
    double dval(cd.dataval[iRow]);
    double weight(cd.datawgt ? cd.datawgt[iRow] : 1.);

    double g(norm0 * weight); // [iRow][iRow]
    for(unsigned iRow2(0); iRow2 != cd.nData; ++iRow2){
      if(iRow2 == iRow) continue;
      double c((dval - cd.dataval[iRow2]) / cd.h0);
      double incr(TMath::Exp(-0.5 * c * c) * norm0);
      if(cd.datawgt) incr *= cd.datawgt[iRow2];
      g += incr;
    }

    double h(cd.h1 / TMath::Sqrt(g) * cd.rho);

    double norm(1. / cd.sumw / h / sqrt2pi);

    int iCenterLeft((dval - cd.xmin) / cd.delta); // left-next integer of actual center
    int iLow((dval - cutoff * h - cd.xmin) / cd.delta + 1);
    int nD(iCenterLeft - iLow + 1);

    for(int iD(0); iD < nD; ++iD){
      int iLeft(iCenterLeft - iD);
      if(iLeft >= cd.nP) continue;
      int iRight(iCenterLeft + 1 + iD);
      if(iRight < 0) continue;
      if(iLeft < 0 && iRight >= cd.nP) break;

      double xval(cd.xmin + cd.delta * iLeft);
      double c((xval - dval) / h);
      double yval(TMath::Exp(-0.5 * c * c) * norm * weight);

      if(iLeft >= 0) cd.yvals[iLeft] += yval;
      if(iRight < cd.nP) cd.yvals[iRight] += yval;
    }
  }

  return _cd;
}
