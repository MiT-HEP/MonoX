/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/

#ifndef KEYSSHAPE
#define KEYSSHAPE

#include "StaticShape.h"

#include "TTree.h"

#include "RooDataSet.h"

#include <cstring>

class KeysShape : public StaticShape {
 public:
  KeysShape() : StaticShape() {}
  KeysShape(const char *name, const char *title, RooRealVar& _x, TTree& _ntuples, const char* _wgtVar = 0, double _rho = 0.5, unsigned _nCPU = 1, unsigned _nBins = 1000);
  KeysShape(const char *name, const char *title, RooRealVar& _x, RooDataSet& _dataset, double _rho = 0.5, unsigned _nCPU = 1, unsigned _nBins = 1000);
  KeysShape(const KeysShape& other, const char* name = 0) : StaticShape(other, name) {}
  virtual TObject* clone(const char* newname) const { return new KeysShape(*this,newname); }
  inline virtual ~KeysShape() { }

  struct CalcData {
    unsigned nData{0};
    double sumw{0.};
    double h0{0.};
    double h1{0.};
    double const* dataval{0};
    double const* datawgt{0};
    double xmin{0.};
    double delta{0.};
    double rho{0.};
    bool ownYvals{false};
    int nP{0};
    double* yvals{0};
    unsigned offset{0};
    unsigned step{0};

    CalcData() {}
    CalcData(int nP, double* yvals = 0);
    CalcData(CalcData const&);
    ~CalcData() { if(ownYvals) delete [] yvals; }
    CalcData& operator=(CalcData const&);

    ClassDef(CalcData,1)
  };

 private:
  void _calculate(unsigned, double const*, double const*, double, unsigned);

  static void* _calculateYVals(void*);

  ClassDef(KeysShape,1) // Static shape from kernel estimation of a dataset
};

inline
KeysShape::CalcData::CalcData(int _nP, double* _yvals/* = 0*/) :
 ownYvals(_yvals == 0),
 nP(_nP),
 yvals(_yvals)
{
  if(ownYvals){
    yvals = new double[nP];
    std::fill_n(yvals, nP, 0.);
  }
}

inline
KeysShape::CalcData::CalcData(CalcData const& _orig) :
 nData(_orig.nData),
 sumw(_orig.sumw),
 h0(_orig.h0),
 h1(_orig.h1),
 dataval(_orig.dataval),
 datawgt(_orig.datawgt),
 xmin(_orig.xmin),
 delta(_orig.delta),
 rho(_orig.rho),
 ownYvals(_orig.ownYvals),
 nP(_orig.nP),
 yvals(_orig.yvals),
 offset(_orig.offset),
 step(_orig.step)
{
  if(ownYvals){
    yvals = new double[nP];
    std::memcpy(yvals, _orig.yvals, sizeof(double) * nP);
  }
}

inline
KeysShape::CalcData&
KeysShape::CalcData::operator=(CalcData const& _rhs)
{
  nData = _rhs.nData; sumw = _rhs.sumw; h0 = _rhs.h0; h1 = _rhs.h1; dataval = _rhs.dataval; datawgt = _rhs.datawgt;
  xmin = _rhs.xmin; delta = _rhs.delta; rho = _rhs.rho; ownYvals = _rhs.ownYvals;
  if(ownYvals){
    if(nP != _rhs.nP){
      nP = _rhs.nP;
      delete [] yvals;
      yvals = new double[nP];
    }
    std::memcpy(yvals, _rhs.yvals, sizeof(double) * nP);
  }
  else{
    nP = _rhs.nP;
    yvals = _rhs.yvals;
  }
  offset = _rhs.offset; step = _rhs.step;
  return *this;
}
 
#endif
